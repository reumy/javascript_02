## 함수
- 상자에 담는 수
- 함수는 값으로써 활용이 됨, 값은 변수에 담길 수 있음
- function : 녹즙기<br />( ) : 녹즙기에 넣을 것<br />{ } : 갈아주는 것(즙반환)

### 이름이 있는 함수
```
function name(){}
```
> es5

#### 함수의 name
- 기능 사용과 검색을 위함
- 카멜표기법 : 두개의 단어연결 (ex. helloWorld)
- 맨앞에 문자를 대문자로 사용하면 해당 함수를 클래스로 사용하겠다는 의미가 됨
 
#### 함수를 사용하는 이유
- 자주 사용하는 코드를 '별도의 파일'로 만들어 필요할때마다 '재활용'할 수 있음
- 코드를 개선하면 이를 사용하는 모든 어플리케이션의 동작이 개선됨
- 코드의 수정시 필요한 로직을 빠르게 찾을 수 있음 (그래서 의미있게 이름을 짓는것도 중요)
- 필요한 로직만을 로드해서 메모리의 낭비를 일 수 있음
```
console.log(a);  // undefined

var a = '사용';

console.log(a);  // 사용
```
> 위에 콘솔은 변수보다 먼저 사용되어 a 를 찾을 수 없음<br />여기에서 콘솔은 사용됐다고 함
```
name();  // call

function name(){
  console.log('call');
}

name();  // call
```
> 함수는 사용했다기보다 호출(call, callback)개념

### 익명함수
- 변수에 담길 수 있음
```
funciton (){}
```
```
open();  // 실행X

var open = function(){
  console.log('익명함수');
}

open();  // 익명함수
```
> 변수로 만들어진 함수는 만들어진 시점보다 아래에 있어야만 실행됨 (이것은 단순히 변수의 성질인 것)

> 위에 호출이 undefined가 아니고 그냥 실행되지 않은 이유는 이름을 찾기보다 함수를 찾기때문

```
var open = function aa(){
  console.log('aa');
}

aa();  // 에러
```
- 일회용 : 함수의 의미가 떨어짐
```
(function fc(){
  console.log('자체실행');
})
```
> 변수안에 들어있다 생각하고 뒤에 괄호를 붙히면 실행된다는 의미로 자체실행이 됨


## 함수의 반환(return)
- return : 원하는 값을 돌려줌(반환)
- 함수는 함수안에서 return을 만나면 종료되어 뒤에 내용은 읽지도 않음
- return은 함수에서만 사용!
```
function plus(){
  console.log('aa');
  return 10+20;
}
```
```
var result = plus();
```
> result는 plus에 반환된 30을 넣는다는 의미<br />plus를 호출시켜서 콘솔은 찍히나 30을 출력해줄 명령어는 없어서 30은 출력이 안됨
```
plus();
```
> 10+20을 돌려받음 출력X
```
console.log(plus());  // aa, 30
console.log(result);  // aa, 30
```
```
function plus(){
  if ( 10 < 5 ){
    return 10+20;
  }
  return '잘못된 비교 입니다.';
}

plus();  // 잘못된 비교입니다.
```
> 위에 return이 false라서 아래 return을 출력
```
function plus2(){
  if ( 10 > 5 ){
    10+20;
  }
  return '잘못된 비교 입니다.';
}
plus2();  // 잘못된 비교입니다.
```
> 30을 가지고는 있지만 return을 만나지 않았으므로 값이 반환되지는 않음 즉, 함수는 return을 만나야만 값이 반환되어 출력됨
```
var num3 = 300;

function plus(){
  var num1 = 100;
  var num2 = 200;

  if ( num1 < num3 ) {
    return num1 + num2;
  }
  return '잘못된 비교입니다.';
}

plus();  // 300
```
> 기능으로써 활용되는것이 아닌 그냥 결과로써로만 활용됨 즉, 더하는 기능이 아니라 그냥 값이 300인 함수
```
var num3 = 300;

function plus(a=50,b=70){  // a,b는 parameter
  var num1 = 100;
  var num2 = 200;

  if (num1 < num3){
    return a + b;
  }
  return '잘못된 비교 입니다.';
}
```
> num3보다 작아야만 실행되는 더하기 기능
- parameter(매개변수) : 함수에서 활용하고 싶은 것 (결국 변수)
> 50, 70은 초기값으로 누군가 실행할때 데이터를 주면 변수라서 값이 변함
```
var result = plus(10,20);
console.log(result);  // 30
```
> 원하는 데이터를 파라미터와 같은 순서로 보내면 됨
```
var result = plus(10,0,20);
```
> 갯수가 안맞아도 에러나지는 않음 받기는 하지만 활용할 수 는 없는 상태인 것

### 매개변수(parameter)
- 사용되는 시점이 달라서 이름에 '매개'가 붙음 결국, 변수라서 변수로서의 사용방식을 가짐
- 매개변수는 지역변수와 비슷하며 맨 꼭대기에 변수를 만든것과 같은 의미
```
funtion ex(a, b){
  var a
  var b
  console.log(a, b);
}
```
> 이 모양과 같음
```
function sum(n1,n2,n3){
  return n1 + n2 + n3;
}

var res1 = sum(100,200,50);
console.log(res1);  // 350
```
```
var res2 = sum(200,400);
console.log(res2);  // NaN
```
> 재활용 / 갯수가 맞지않아서 계산 불가능
```
function sum(n1,n2,n3 = 0){
  return n1 + n2 + n3;
}

var res2 = sum(200,400);
console.log(res2);  // 600
```
> 초기값을 넣어주면 갯수가 안맞아도 계산가능
- 갯수에 구애없는 더하기 기능 만들기
```
function sum(arr){

  var total = 0;

  for (var i = 0; i < arr.length; i++) {
    total = total + arr[i];
  }
  return total;
}

var res1 = sum([100,200,50]);
var res2 = sum([200,400,100,200,300]);

console.log(res1);  // 350
console.log(res2);  // 1200
```
> 사용자가 배열로 주면 모든값을 더해주는 기능 단, 배열로 보내지 않으면 계산이 안됨 (강제성)
- 규칙을 정해서 조건을 던져놓으면 사용자들의 책임이나 내가 일일히 체크하면서 개발해 오류가나면 내 책임이 됨 예외가 많아지는 개발일수록 힘들어짐 그렇기때문에 `조금의 강제성은 반드시 필요함` (ex. 비밀번호 9자리)


### 변수의 관계 (호이스트)
- 호이스트 : 끌어올리다
```
console.log(p);  // undefined (호이스트)

var p = 10;

console.log(p);  // 10
```
- 변수가 생기면 `변수는 가장 꼭대기로 올라가지만 변수에 적용된 값은 변수가 실제로 위치한곳에서 적용`되기때문에 위에서는 인지하지 못함 즉, `값은 뒤에 들어감`
```
var x = 10;

function up(){
  // var x;
  console.log(x);  // undefined (호이스트)
  var x = 20;
  console.log(x);  // 20
}

up();
```
- `var는 함수단위의 변수`라서 var는 함수를 벗어나지 못하므로 함수의 맨 꼭대기로 올라감
